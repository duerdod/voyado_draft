{"version":3,"file":"flight-voyado.cjs.production.min.js","sources":["../src/states/GlobalActivation.ts","../src/hooks/useGlobalActivation.ts","../src/resolvers/index.ts","../src/VoyadoProvider.tsx","../src/states/ExternalLookup.ts","../src/hooks/useVoyadoLookup.ts"],"sourcesContent":["import { assign, Machine, send, DoneEventObject } from 'xstate';\n\nexport interface VoyadoProviderOptions {\n  loginPath?: string;\n  signupPath?: string;\n  loginOnActivation?: boolean;\n  manualActivation: boolean;\n}\n\nexport interface VoyadoActivationContext {\n  externalCustomerToken: string;\n  customer: any;\n  status: StateEventMapperIndex;\n  providerOptions: VoyadoProviderOptions;\n}\n\nconst defaultproviderOptions: VoyadoProviderOptions = {\n  loginPath: '/login',\n  signupPath: '/signup',\n  loginOnActivation: true,\n  manualActivation: false,\n};\n\ninterface ActivationSchema {\n  states: {\n    idle: {};\n    activated: {};\n    checking_action_required: {};\n    no_action_required: {};\n    action_required: {\n      states: {\n        try_activate: {};\n        activation_failed: {\n          states: {\n            status_response: {};\n            non_existing: {};\n            already_activated: {};\n            additional_data: {};\n          };\n        };\n      };\n    };\n  };\n}\n\ntype ActivationEvents =\n  | { type: 'CHECKING_ACTION_REQUIRED'; data: any }\n  | { type: 'NON_EXISTING_CUSTOMER'; data: any }\n  | { type: 'ALREADY_ACTIVATED'; data: any }\n  | { type: 'ACTIVATION_REQUIRED'; data: any }\n  | { type: 'ADDITIONAL_DATA_REQUIRED'; data: any }\n  | DoneEventObject;\n\ntype StateEventMapperIndex =\n  | 'NoActionRequired' // Dummy\n  | 'CustomerNotFound'\n  | 'CustomerAlreadyActivated'\n  | 'AdditionalUserDataRequired';\n\nconst StateEventMapper: { [key in StateEventMapperIndex]: string } = {\n  NoActionRequired: 'NO_ACTION_REQUIRED',\n  CustomerNotFound: 'NON_EXISTING_CUSTOMER',\n  CustomerAlreadyActivated: 'ALREADY_ACTIVATED',\n  AdditionalUserDataRequired: 'ADDITIONAL_DATA_REQUIRED',\n};\n\nconst sendActionEvent = send((context: VoyadoActivationContext) => ({\n  type: StateEventMapper[context.status],\n}));\n\nconst setStatusReason = assign<VoyadoActivationContext, ActivationEvents>({\n  status: (_, event: ActivationEvents) => {\n    const [errorType] = event.data.error;\n    return errorType.message || ('NoActionRequired' as StateEventMapperIndex);\n  },\n  customer: (_: any, event: ActivationEvents) => {\n    if (event.data.activateExternalCustomerByToken) {\n      return { ...event.data.activateExternalCustomerByToken.customer };\n    } else {\n      return undefined;\n    }\n  },\n});\n\nconst storeCustomer = assign<VoyadoActivationContext, ActivationEvents>({\n  customer: (context: VoyadoActivationContext, event: ActivationEvents) => {\n    if (event.data?.externalCustomerLookup?.customer) {\n      return {\n        ...context.customer,\n        ...event.data.externalCustomerLookup.customer,\n        // Since there is a mismatch between SignupInput type and ExternalLookup type\n        streetName: event.data.externalCustomerLookup.customer.address,\n        mobilePhone: event.data.externalCustomerLookup.customer.mobilePhoneNumber,\n      };\n    } else {\n      return {\n        ...context.customer,\n      };\n    }\n  },\n});\n\nexport const createActivationMachine = (providerOptions: VoyadoProviderOptions) =>\n  Machine<VoyadoActivationContext, ActivationSchema, ActivationEvents>(\n    {\n      id: 'ActivationMachine',\n      initial: 'idle',\n      context: {\n        externalCustomerToken: '',\n        customer: undefined,\n        status: 'NoActionRequired',\n        providerOptions: {\n          ...defaultproviderOptions,\n          ...providerOptions,\n        },\n      },\n      states: {\n        idle: {\n          always: [\n            {\n              target: 'checking_action_required',\n              cond: 'shouldInitialize',\n            },\n            {\n              target: 'no_action_required',\n            },\n          ],\n        },\n        activated: {\n          // Log in.\n          always: [\n            {\n              target: 'checking_action_required',\n              cond: (context: VoyadoActivationContext) =>\n                context.providerOptions.loginOnActivation!,\n            },\n            {\n              target: 'no_action_required',\n            },\n          ],\n        },\n        checking_action_required: {\n          invoke: {\n            id: 'tryLogin',\n            src: 'tryLogin',\n            onDone: 'no_action_required',\n            onError: 'action_required',\n          },\n        },\n        no_action_required: {\n          type: 'final',\n        },\n        action_required: {\n          id: 'action_required',\n          initial: 'try_activate',\n          states: {\n            try_activate: {\n              invoke: {\n                id: 'tryActivateByToken',\n                src: 'tryActivateByToken',\n                onDone: {\n                  target: '#ActivationMachine.activated',\n                },\n                onError: {\n                  target: 'activation_failed',\n                  actions: ['setStatusReason', 'sendActionEvent'],\n                },\n              },\n            },\n            activation_failed: {\n              id: 'activation_failed',\n              initial: 'status_response',\n              states: {\n                status_response: {\n                  on: {\n                    NON_EXISTING_CUSTOMER: 'non_existing',\n                    ALREADY_ACTIVATED: 'already_activated',\n                    ADDITIONAL_DATA_REQUIRED: 'additional_data',\n                    NO_ACTION_REQUIRED: 'non_existing',\n                  },\n                },\n                non_existing: {\n                  type: 'final',\n                },\n                already_activated: {\n                  type: 'final',\n                },\n                additional_data: {\n                  type: 'final',\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n    {\n      actions: {\n        setStatusReason,\n        sendActionEvent,\n        storeCustomer,\n      },\n    }\n  );\n","import { useEffect } from 'react';\n\nimport { createActivationMachine, VoyadoProviderOptions } from '../states/GlobalActivation';\nimport { useMachine } from '@xstate/react';\n\nimport { useApolloClient } from '@apollo/react-hooks';\n\nimport useAuth from '@jetshop/core/components/AuthContext/useAuth';\n\nimport { useLocation, useHistory } from 'react-router';\nimport qs from 'qs';\n\nimport * as resolver from '../resolvers';\n\nexport function useGlobalActivation(providerOptions: VoyadoProviderOptions) {\n  const history = useHistory();\n  const client = useApolloClient();\n  const { search } = useLocation();\n  const { loggedIn, logIn } = useAuth();\n  const { eclub = '' } = qs.parse(search, { ignoreQueryPrefix: true });\n\n  const [state] = useMachine(createActivationMachine(providerOptions), {\n    context: {\n      externalCustomerToken: encodeURIComponent(eclub as string),\n    },\n    services: {\n      tryLogin: context => {\n        return resolver.tryLogin(context, {\n          client,\n          callback: logIn,\n        });\n      },\n      tryActivateByToken: context => {\n        return resolver.tryActivateByToken(context, { client });\n      },\n    },\n    guards: {\n      shouldInitialize: () => (eclub as string).length > 0 && !loggedIn,\n    },\n  });\n\n  console.log('GlobalActivationState: ', JSON.stringify(state.value));\n\n  const states = {\n    isAdditionalDataRequired: state.matches('action_required.activation_failed.additional_data'),\n    isNonExistingCustomer: state.matches('action_required.activation_failed.non_existing'),\n    isActivationRequired: state.matches('action_required.activation_failed.already_activated'),\n    // The following might cause impossible states...\n    isActionPending:\n      state.matches('checking_action_required') ||\n      state.matches('action_required.try_activate') ||\n      state.matches('action_required.activation_failed.status_response'),\n  };\n\n  useEffect(() => {\n    if (states.isAdditionalDataRequired) {\n      history.push(providerOptions.signupPath || '/signup', {\n        customer: { ...state.context.customer },\n      });\n    }\n  }, [states.isAdditionalDataRequired]);\n\n  return {\n    ...states,\n  };\n}\n","import ApolloClient from 'apollo-client';\nimport { LookupContext, LookupEvents } from '../states/ExternalLookup';\nimport { VoyadoActivationContext } from '../states/GlobalActivation';\n\nimport ActivateExternalCustomerByToken from '../queries/ActivateExternalCustomerByToken.gql';\nimport ActivateExternalId from '../queries/ActivateExternalId.gql';\nimport ExternalLookupQuery from '../queries/ExternalLookupQuery.gql';\nimport LoginExternalCustomer from '../queries/LoginExternalCustomer.gql';\nimport LookupQuery from '../queries/LookupQuery.gql';\n\n// Semi login resolvers\nfunction tryLogin(\n  context: VoyadoActivationContext,\n  options: {\n    client: ApolloClient<any>;\n    callback: (token: string) => void;\n  }\n) {\n  const logIn = options.callback;\n  return options.client\n    .mutate({\n      mutation: LoginExternalCustomer,\n      variables: {\n        input: {\n          externalCustomerToken: context.externalCustomerToken,\n        },\n      },\n    })\n    .then(\n      ({ data }) => {\n        if (data?.loginExternalCustomer.token?.value) {\n          return Promise.resolve(logIn(data?.loginExternalCustomer?.token?.value));\n        } else {\n          return Promise.reject();\n        }\n      },\n      error => {\n        return Promise.reject(error);\n      }\n    );\n}\n\nfunction tryActivateByToken(\n  context: VoyadoActivationContext,\n  options: {\n    client: ApolloClient<any>;\n    callback?: any;\n  }\n) {\n  return (\n    options.client\n      .mutate({\n        mutation: ActivateExternalCustomerByToken,\n        variables: {\n          input: { externalCustomerToken: context.externalCustomerToken },\n        },\n        // This is needed because we're using both the error and data to decide the next event.\n        errorPolicy: 'all',\n      })\n      // Change this when API is returning a status like we do on external lookup.\n      // If we got a status, we could just forward them as event.type.\n      .then(({ data, errors }) => {\n        if (errors) {\n          return Promise.reject({ error: { ...errors }, ...data });\n        } else {\n          return Promise.resolve(data);\n        }\n      })\n  );\n}\n\n// Lookup resolvers\nfunction externalLookup(\n  event: LookupEvents,\n  options: {\n    client: ApolloClient<any>;\n  }\n) {\n  return options.client\n    .query({\n      query: ExternalLookupQuery,\n      variables: { key: event.data.key },\n    })\n    .then(({ data }) => data);\n}\n\nfunction activateExternalId(\n  context: LookupContext,\n  options: {\n    client: ApolloClient<any>;\n  }\n) {\n  return options.client\n    .mutate({\n      mutation: ActivateExternalId,\n      variables: {\n        input: { externalCustomerId: context.customer.externalId },\n      },\n    })\n    .then(({ data }) => data);\n}\n\nfunction personLookup(\n  context: LookupContext,\n  options: {\n    client: ApolloClient<any>;\n  }\n) {\n  return options.client\n    .query({\n      query: LookupQuery,\n      variables: { key: context.customer.emailAddress },\n    })\n    .then(({ data }) => data);\n}\n\nexport { tryLogin, tryActivateByToken, externalLookup, activateExternalId, personLookup };\n","import React, { createContext, useContext } from 'react';\n\nimport { useGlobalActivation } from './hooks/useGlobalActivation';\nimport { VoyadoProviderOptions } from './states/GlobalActivation';\n\nexport const VoyadoContext = createContext({});\n\ninterface VoyadoProviderProps {\n  children: React.ReactNode;\n  options: VoyadoProviderOptions;\n}\n\nexport const VoyadoProvider = (props: VoyadoProviderProps) => {\n  const activationValues = useGlobalActivation({\n    ...props.options,\n  });\n  return <VoyadoContext.Provider value={activationValues} {...props} />;\n};\n\nexport function useGlobalActivationStatus() {\n  const context = useContext(VoyadoContext);\n  if (!context) {\n    return Error('useGlobalActivationStatus cannot be used outside VoyadoProvider');\n  }\n  return context;\n}\n","// @ts-nocheck\n\nimport { Machine, assign, send, DoneEventObject } from 'xstate';\n\nconst EVENTS = {\n  ACTIVATION_REQUIRED: 'ACTIVATION_REQUIRED',\n  PREEXISTING_CUSTOMER: 'PREEXISTING_CUSTOMER',\n  ADDITIONAL_USER_DATA_REQUIRED: 'ADDITIONAL_USER_DATA_REQUIRED',\n  NON_EXISTING_CUSTOMER: 'NON_EXISTING_CUSTOMER',\n};\n\nexport interface LookupContext {\n  customer: any;\n  activationError: null | string;\n  lookupOptions: LookupOptions;\n}\n\nexport const defaultLookupOptions: LookupOptions = {\n  activateOnLookup: true,\n  signInOnActivation: false,\n};\n\ninterface LookupOptions {\n  activateOnLookup?: boolean;\n  signInOnActivation?: boolean;\n}\n\nexport interface LookupSchema {\n  states: {\n    idle: {};\n    lookup: {\n      states: {\n        lookup_loading: {};\n        lookup_failed: {};\n        lookup_success: {\n          states: {\n            status_response: {};\n            activation: {\n              states: {\n                activation_required: {};\n                activation_loading: {};\n                activation_success: {\n                  states: {\n                    try_login: {};\n                    login: {};\n                    login_failed: {};\n                    customer_created: {};\n                  };\n                };\n                activation_failed: {};\n              };\n            };\n            additional_data: {};\n            preexisting: {};\n            non_existing: {\n              states: {\n                non_existing_customer: {};\n                person_lookup_loading: {};\n                person_lookup_success: {};\n                person_lookup_failed: {};\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n}\n\nexport type LookupEvents =\n  | { type: 'DO_LOOKUP'; data: { key?: string } }\n  | { type: 'ACTIVATION_REQUIRED'; data: any }\n  | { type: 'PREEXISTING_CUSTOMER'; data: any }\n  | { type: 'ADDITIONAL_USER_DATA_REQUIRED'; data: any }\n  | { type: 'NON_EXISTING_CUSTOMER'; data: any }\n  | { type: 'ACTIVATE_CUSTOMER'; data?: any }\n  | { type: 'RETRY'; data?: any }\n  | DoneEventObject;\n\nconst sendLookupSuccessEvent = send((_: any, event: LookupEvents) => ({\n  type: event.data.externalCustomerLookup.status,\n  data: event.data.externalCustomerLookup,\n}));\n\nconst storeEmail = assign<LookupContext, LookupEvents>({\n  customer: (context: LookupContext, event: LookupEvents) => ({\n    ...context.customer,\n    emailAddress: {\n      masked: event.data.key,\n    },\n  }),\n});\n\nconst storeCustomer = assign<LookupContext, LookupEvents>({\n  customer: (context: LookupContext, event: LookupEvents) => {\n    if (event.data?.externalCustomerLookup?.customer) {\n      return {\n        ...context.customer,\n        ...event.data.externalCustomerLookup.customer,\n        // Since there is a mismatch between SignupInput and ExternalLookup\n        streetName: event.data.externalCustomerLookup.customer.address,\n        mobilePhone: event.data.externalCustomerLookup.customer.mobilePhoneNumber,\n      };\n    } else {\n      return {\n        ...context.customer,\n      };\n    }\n  },\n});\n\nconst storeLookupData = assign<LookupContext, LookupEvents>({\n  customer: (context: LookupContext, event: LookupEvents) => {\n    if (event?.data?.personLookup) {\n      return { ...event.data.personLookup };\n    } else {\n      return { ...context.customer };\n    }\n  },\n});\n\nconst storeToken = assign<LookupContext, LookupEvents>({\n  customer: (context: LookupContext, event: LookupEvents) => ({\n    ...context.customer,\n    token: event.data.activateExternalCustomerById.token.value,\n  }),\n});\n\nconst setActivationError = assign<LookupContext, LookupEvents>({\n  activationError: event => '',\n});\n\nexport const LookupMachine = Machine<LookupContext, LookupSchema, LookupEvents>(\n  {\n    id: 'LookupMachine',\n    initial: 'idle',\n    context: {\n      activationError: null,\n      customer: undefined,\n      lookupOptions: {},\n    },\n    states: {\n      idle: {\n        id: 'idle',\n        on: {\n          DO_LOOKUP: 'lookup',\n        },\n      },\n      lookup: {\n        entry: 'storeEmail',\n        initial: 'lookup_loading',\n        states: {\n          lookup_loading: {\n            invoke: {\n              id: 'fetchLookupStatus',\n              src: 'externalLookup',\n              onDone: {\n                target: 'lookup_success',\n                actions: ['sendLookupSuccessEvent'],\n              },\n              onError: 'lookup_failed',\n            },\n          },\n          lookup_failed: {\n            on: {\n              RETRY: '#idle',\n            },\n          },\n          lookup_success: {\n            initial: 'status_response',\n            entry: 'storeCustomer',\n            states: {\n              status_response: {\n                on: {\n                  [EVENTS.ACTIVATION_REQUIRED]: '#activation',\n                  [EVENTS.PREEXISTING_CUSTOMER]: '#preexisting',\n                  [EVENTS.ADDITIONAL_USER_DATA_REQUIRED]: '#additional_data',\n                  [EVENTS.NON_EXISTING_CUSTOMER]: '#non_existing',\n                },\n              },\n              // Account needs activation.\n              activation: {\n                id: 'activation',\n                initial: 'activation_required',\n                states: {\n                  activation_required: {\n                    always: {\n                      target: 'activation_loading',\n                      cond: (context: LookupContext) => context.lookupOptions.activateOnLookup!,\n                    },\n                    on: {\n                      ACTIVATE_CUSTOMER: 'activation_loading',\n                    },\n                  },\n                  activation_loading: {\n                    invoke: {\n                      id: 'activate-customer-by-externalid',\n                      src: 'activateExternalId',\n                      onDone: {\n                        actions: 'storeToken',\n                        target: 'activation_success',\n                      },\n                      onError: 'activation_failed',\n                    },\n                  },\n                  activation_success: {\n                    id: 'activation_success',\n                    initial: 'try_login',\n                    states: {\n                      try_login: {\n                        always: [\n                          {\n                            target: 'login',\n                            cond: (context: LookupContext) =>\n                              context.lookupOptions.signInOnActivation!,\n                          },\n                          {\n                            target: 'customer_created',\n                          },\n                        ],\n                      },\n                      login: {\n                        invoke: {\n                          id: 'login',\n                          src: 'login',\n                          onDone: 'customer_created',\n                          onError: 'login_failed',\n                        },\n                      },\n                      login_failed: {\n                        type: 'final',\n                      },\n                      customer_created: {\n                        type: 'final',\n                      },\n                    },\n                  },\n                  activation_failed: {\n                    entry: 'setActivationError',\n                    on: {\n                      RETRY: '#idle',\n                    },\n                  },\n                },\n              },\n              preexisting: {\n                // Can login.\n                id: 'preexisting',\n                type: 'final',\n              },\n              additional_data: {\n                // Need more data to actually create a customer.\n                id: 'additional_data',\n                type: 'final',\n              },\n              // Customer does not exist. Try fetch required information.\n              non_existing: {\n                id: 'non_existing',\n                initial: 'non_existing_customer',\n                states: {\n                  non_existing_customer: {\n                    always: {\n                      target: 'person_lookup_loading',\n                    },\n                  },\n                  person_lookup_loading: {\n                    invoke: {\n                      id: 'fetch_person_lookupdata',\n                      src: 'personLookup',\n                      onDone: {\n                        target: 'person_lookup_success',\n                      },\n                      onError: 'person_lookup_failed',\n                    },\n                    exit: 'storeLookupData',\n                  },\n                  person_lookup_success: {\n                    type: 'final',\n                  },\n                  person_lookup_failed: {\n                    type: 'final',\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    actions: {\n      sendLookupSuccessEvent,\n      setActivationError,\n      storeEmail,\n      storeCustomer,\n      storeToken,\n      storeLookupData,\n    },\n  }\n);\n","import { useMachine } from '@xstate/react';\nimport {\n  LookupMachine,\n  LookupContext,\n  LookupEvents,\n  defaultLookupOptions,\n} from '../states/ExternalLookup';\nimport { useApolloClient } from '@apollo/react-hooks';\nimport useAuth from '@jetshop/core/components/AuthContext/useAuth';\n\nimport * as resolver from '../resolvers';\n\nexport function useVoyadoLookup(options: Partial<LookupContext>) {\n  const client = useApolloClient();\n  const { logIn } = useAuth();\n  const [state, send] = useMachine(LookupMachine, {\n    services: {\n      externalLookup: (_, event: LookupEvents) => {\n        return resolver.externalLookup(event, {\n          client,\n        });\n      },\n      activateExternalId: (context: LookupContext) => {\n        return resolver.activateExternalId(context, {\n          client,\n        });\n      },\n      personLookup: (context: LookupContext) => {\n        return resolver.personLookup(context, {\n          client,\n        });\n      },\n      login: (context: LookupContext) => Promise.resolve(logIn(context.customer.token)),\n    },\n    context: {\n      customer: null,\n      lookupOptions: {\n        ...defaultLookupOptions,\n        ...options,\n      },\n    },\n  });\n\n  const lookup = (key: string) => {\n    send({ type: 'DO_LOOKUP', data: { key } });\n  };\n\n  const activate = () => {\n    send({ type: 'ACTIVATE_CUSTOMER' });\n  };\n\n  const retryLookup = () => {\n    send({ type: 'RETRY' });\n  };\n\n  // Surface API responses.\n  const states = {\n    isActivationRequired: state.matches('lookup.lookup_success.activation.activation_required'),\n    isActivationPending: state.matches('lookup.lookup_success.activation.activation_loading'),\n    isActivationSuccess: state.matches(\n      'lookup.lookup_success.activation.activation_success.customer_created'\n    ),\n    isPreExistingCustomer: state.matches('lookup.lookup_success.preexisting'),\n    IsAdditionalDataRequired: state.matches('lookup.lookup_success.additional_data'),\n    isNonExistingCustomer: state.matches('lookup.lookup_success.non_existing'),\n    isPersonLookupPending: state.matches(\n      'lookup.lookup_success.non_existing.person_lookup_loading'\n    ),\n    hasPersonLookupData: state.matches('lookup.lookup_success.non_existing.person_lookup_success'),\n    error: {\n      lookupError: state.matches('lookup.lookup_failed'),\n      activationError: state.matches('lookup.lookup_success.activation.activation_failed'),\n      errorMessage: state.context.activationError,\n    },\n  };\n\n  console.log('VoyadoLookupState: ', JSON.stringify(state.value));\n\n  return {\n    lookup,\n    activate,\n    retryLookup,\n    ...states,\n    customer: state.context.customer,\n  };\n}\n"],"names":["defaultproviderOptions","loginPath","signupPath","loginOnActivation","manualActivation","StateEventMapper","NoActionRequired","CustomerNotFound","CustomerAlreadyActivated","AdditionalUserDataRequired","sendActionEvent","send","context","type","status","setStatusReason","assign","_","event","data","error","message","customer","activateExternalCustomerByToken","storeCustomer","_event$data","externalCustomerLookup","_event$data$externalC","streetName","address","mobilePhone","mobilePhoneNumber","createActivationMachine","providerOptions","Machine","id","initial","externalCustomerToken","undefined","states","idle","always","target","cond","activated","checking_action_required","invoke","src","onDone","onError","no_action_required","action_required","try_activate","actions","activation_failed","status_response","on","NON_EXISTING_CUSTOMER","ALREADY_ACTIVATED","ADDITIONAL_DATA_REQUIRED","NO_ACTION_REQUIRED","non_existing","already_activated","additional_data","useGlobalActivation","history","useHistory","client","useApolloClient","search","useLocation","useAuth","loggedIn","logIn","qs","parse","ignoreQueryPrefix","eclub","state","useMachine","encodeURIComponent","services","tryLogin","options","callback","mutate","mutation","LoginExternalCustomer","variables","input","then","loginExternalCustomer","token","_data$loginExternalCu","value","Promise","resolve","_data$loginExternalCu2","_data$loginExternalCu3","reject","resolver","tryActivateByToken","ActivateExternalCustomerByToken","errorPolicy","errors","guards","shouldInitialize","length","console","log","JSON","stringify","isAdditionalDataRequired","matches","isNonExistingCustomer","isActivationRequired","isActionPending","useEffect","push","VoyadoContext","createContext","defaultLookupOptions","activateOnLookup","signInOnActivation","sendLookupSuccessEvent","storeEmail","emailAddress","masked","key","storeLookupData","_event$data2","personLookup","storeToken","activateExternalCustomerById","setActivationError","activationError","LookupMachine","lookupOptions","DO_LOOKUP","lookup","entry","lookup_loading","lookup_failed","RETRY","lookup_success","activation","activation_required","ACTIVATE_CUSTOMER","activation_loading","activation_success","try_login","login","login_failed","customer_created","preexisting","non_existing_customer","person_lookup_loading","exit","person_lookup_success","person_lookup_failed","props","activationValues","React","Provider","useContext","Error","externalLookup","query","ExternalLookupQuery","activateExternalId","ActivateExternalId","externalCustomerId","externalId","LookupQuery","isActivationPending","isActivationSuccess","isPreExistingCustomer","IsAdditionalDataRequired","isPersonLookupPending","hasPersonLookupData","lookupError","errorMessage","activate","retryLookup"],"mappings":"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"}